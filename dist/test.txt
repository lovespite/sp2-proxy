var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/model/Channel.ts
var import_stream = require("stream");

// src/model/DataPack.ts
function getNullPack(cid) {
  return {
    cid,
    id: 0,
    data: null
  };
}
function slice(data, cid, maxPackSize = 1024) {
  const packs = [];
  let index = 0;
  let offset = 0;
  while (offset < data.length) {
    const pack = {
      cid,
      id: index,
      data: data.subarray(offset, offset + maxPackSize).toString("base64")
    };
    packs.push(pack);
    offset += maxPackSize;
    ++index;
  }
  return packs;
}

// src/model/Channel.ts
var Channel = class extends import_stream.Duplex {
  _id;
  _host;
  _streamBufferIn;
  _finished = false;
  get cid() {
    return this._id;
  }
  constructor(id, host) {
    super();
    this._host = host;
    this._id = id;
    this._streamBufferIn = [];
    this.once("finish", () => {
      console.log("FINISH");
      this._host.enqueueOut([getNullPack(this._id)]);
    });
  }
  _write(chunk, encoding, callback) {
    let packs;
    if (chunk instanceof Buffer) {
      packs = slice(chunk, this._id);
    } else {
      packs = slice(Buffer.from(chunk, encoding), this._id);
    }
    this._host.enqueueOut(packs);
    callback();
  }
  _read(size) {
    const data = this._streamBufferIn.shift();
    if (!data) {
      if (this._finished) {
        this.push(null);
        console.log("READ", "[END]");
      } else {
        console.log("READ", "[WAIT]");
        return;
      }
    } else {
      this.push(data);
      console.log("READ", data.length);
    }
  }
  pushBufferExternal(buffer) {
    if (buffer === null) {
      this._finished = true;
      console.log("C_MESSAGE", "[END]");
    } else {
      if (this._streamBufferIn.length === 0) {
        this.push(buffer);
        console.log("C_DATA", buffer.length);
      } else {
        this._streamBufferIn.push(buffer);
        console.log("C_DATA", buffer.length, "[QUEUE]");
      }
    }
  }
  _destroy(error, callback) {
    this.push(null);
    this._streamBufferIn.length = 0;
    callback();
  }
};

// src/model/ChannelManager.ts
var ChannelManager = class _ChannelManager {
  static _cid = 0;
  static getNextCid() {
    return this._cid++;
  }
  _packCount = 0;
  _droppedCount = 0;
  count() {
    ++this._packCount;
  }
  countDrop() {
    ++this._droppedCount;
  }
  get packCount() {
    return this._packCount;
  }
  get droppedCount() {
    return this._droppedCount;
  }
  _channels = /* @__PURE__ */ new Map();
  constructor(host) {
    this._host = host;
    host.onPackReceived(this.dispatchPack.bind(this));
  }
  getChannel(id) {
    return this._channels.get(id);
  }
  createChannel() {
    const id = _ChannelManager.getNextCid();
    const channel = new Channel(id, this._host);
    this._channels.set(id, channel);
    return channel;
  }
  deleteChannel(chn) {
    chn.destroy();
    this._channels.delete(chn.cid);
  }
  _host;
  async destroy() {
    this._host.destroy();
    this._host.offPackReceived(this.dispatchPack);
    this._channels.forEach((chn) => chn?.destroy());
    this._channels.clear();
  }
  dispatchPack(pack) {
    const channel = this.getChannel(pack.cid);
    if (!channel) {
      console.log("DROP", pack.id, `Chn. <${pack.cid}> not found`);
      this.countDrop();
      return;
    }
    if (channel.destroyed) {
      console.log("DROP", pack.id, `Chn. <${pack.cid}> destroyed`);
      this.countDrop();
      return;
    }
    if (pack.data) {
      channel.pushBufferExternal(Buffer.from(pack.data, "base64"));
    } else {
      channel.pushBufferExternal(null);
    }
    this.count();
  }
};

// src/model/PhysicalPortHost.ts
var import_serialport = require("serialport");

// src/utils/delay.ts
async function delay(msTimeOut) {
  return new Promise((resolve) => setTimeout(resolve, msTimeOut));
}

// src/model/PhysicalPortHost.ts
var PhysicalPortHost = class {
  _queueIncoming;
  _queueOutgoing;
  _physical;
  _parser;
  packEventList = /* @__PURE__ */ new Set();
  _isDestroyed = false;
  _isRunning = false;
  _isFinished = false;
  constructor(port) {
    this._physical = port;
    this._physical.on("error", console.error);
    this._physical.on("close", () => console.log("CLOSED"));
    this._queueIncoming = [];
    this._queueOutgoing = [];
    this._parser = port.pipe(new import_serialport.ReadlineParser({ delimiter: "\r\n" }));
    this._parser.on("data", this.onReceivedInternal.bind(this));
    console.log("Port opened.");
  }
  async waitForFinish() {
    while (!this._isFinished) {
      await delay(100);
    }
  }
  enqueueOut(packs) {
    if (this._isDestroyed || !this._isRunning) {
      throw new Error("Port is not running.");
    }
    this._queueOutgoing.push(...packs);
  }
  onPackReceived(event) {
    this.packEventList.add(event);
  }
  offPackReceived(event) {
    this.packEventList.delete(event);
  }
  async start() {
    if (this._isDestroyed) {
      throw new Error("Port is destroyed.");
    }
    if (this._isRunning) {
      throw new Error("Port is already running.");
    }
    this._isRunning = true;
    await Promise.all([this.startSendingDequeueTask(), this.startReceivingDequeueTask()]);
  }
  async stop() {
    this._isRunning = false;
    await this.waitForFinish();
  }
  async destroy() {
    this._isDestroyed = true;
    await this.stop();
    if (this._physical.isOpen)
      this._physical.close();
    this._parser.destroy();
    this.packEventList.clear();
    this._queueIncoming.length = 0;
    this._queueOutgoing.length = 0;
  }
  onReceivedInternal(data) {
    try {
      const pack = JSON.parse(data);
      if (pack.cid === void 0)
        return;
      this._queueIncoming.push(pack);
      console.log("M_ENQUEUE", pack.cid, pack.id);
    } catch (e) {
      console.log("M_ERROR", e.message, data);
    }
  }
  async startSendingDequeueTask() {
    try {
      while (true) {
        if (!this._isRunning && this._queueOutgoing.length === 0)
          break;
        const pack = await this.blockDequeueOut();
        if (!pack)
          continue;
        if (!this._physical)
          break;
        const json = JSON.stringify(pack);
        this._physical.write(json + "\r\n");
        await new Promise((res) => this._physical.drain(res));
        if (pack.data) {
          console.log("SENT", pack.cid, pack.id, json.length);
        } else {
          console.log("SENT", pack.cid, pack.id, "[END]");
        }
      }
    } catch (e) {
      console.log(e.message);
    }
    this._isFinished = true;
    console.log("SENDING STOPPED");
  }
  emitPackReceived(pack) {
    return new Promise((resolve) => {
      this.packEventList.forEach((event) => {
        try {
          event(pack);
        } catch (e) {
          console.error(e);
        }
      });
      resolve();
    });
  }
  async startReceivingDequeueTask() {
    try {
      while (this._isRunning) {
        const pack = await this.blockDequeueIn();
        this.emitPackReceived(pack);
      }
    } catch (e) {
      console.log(e.message);
    }
    console.log("RECEIVING STOPPED");
  }
  async blockDequeueIn() {
    while (this._queueIncoming.length === 0) {
      await delay(100);
      if (!this._isRunning)
        throw new Error("Port stopped.");
    }
    return this._queueIncoming.shift();
  }
  async blockDequeueOut() {
    while (this._queueOutgoing.length === 0) {
      await delay(100);
      if (!this._isRunning)
        return;
    }
    return this._queueOutgoing.shift();
  }
};

// src/utils/serialportHelp.ts
var import_serialport2 = require("serialport");
async function listSerialPorts() {
  return await import_serialport2.SerialPort.list();
}
async function openSerialPort(portName, baudRate) {
  if (portName.startsWith(".")) {
    const list = await listSerialPorts();
    const index = portName.length - 1;
    if (list.length <= index) {
      throw new Error(`No serial port available at index ${index}`);
    }
    portName = list[index].path;
  }
  if (!baudRate)
    baudRate = 16e5;
  return new Promise((resolve, reject) => {
    const port = new import_serialport2.SerialPort(
      {
        path: portName,
        baudRate,
        autoOpen: true,
        stopBits: 1,
        parity: "none",
        dataBits: 8
      },
      (err) => {
        if (err)
          reject(err);
        else
          resolve(port);
      }
    );
  });
}

// test.ts
var fs = __toESM(require("fs"));
async function test(args2) {
  const test_cmd = args2[0][0];
  console.log(args2);
  switch (test_cmd) {
    case "channel_s":
      await channel_test_server(args2[1][0]);
      break;
    case "channel_c":
      await channel_test_client(args2[1][0], args2[2][0]);
      break;
    default:
      break;
  }
}
async function channel_test_server(portName) {
  const physicalPort = await openSerialPort(portName, 16e5);
  const host = new PhysicalPortHost(physicalPort);
  host.start();
  const chnMan = new ChannelManager(host);
  const chn1 = chnMan.createChannel();
  const fileStream = fs.createWriteStream("test.txt");
  chn1.pipe(fileStream);
  await new Promise((res) => chn1.once("end", res));
  console.log("File finished.");
  fileStream.close();
  await chnMan.destroy();
}
async function channel_test_client(portName, file) {
  const physicalPort = await openSerialPort(portName, 16e5);
  const host = new PhysicalPortHost(physicalPort);
  host.start();
  const chnMan = new ChannelManager(host);
  const chn1 = chnMan.createChannel();
  const fileStream = fs.createReadStream(file);
  console.log("Streaming...");
  fileStream.pipe(chn1);
  await new Promise((res) => {
    chn1.on("finish", res);
  });
  chn1.destroy();
  console.log("Done.");
  fileStream.close();
  await chnMan.destroy();
}

// src/utils/help.ts
function printUsage() {
  console.log(`Usage: node ${process.argv[1]} <command> [options]`);
  console.log("General options:");
  console.log(`  --serialPort, -s <path>`);
  console.log(`    Specify the serial port to connect.`);
  console.log(`    Default: . (Use the first available port)`);
  console.log(`  --baudRate, -b <baudRate>`);
  console.log(`    Specify the baud rate.`);
  console.log(`    Default: 1600000`);
  console.log(``);
  console.log(`Commands:`);
  console.log(`  list`);
  console.log(`    List all available serial ports.`);
  console.log(`  proxy [options]`);
  console.log(`    Start the intermedia proxy server.`);
  console.log(`    Options:`);
  console.log(`      --listen, -l <ip>`);
  console.log(`        Specify the IP address to listen.`);
  console.log(`        Default: 0.0.0.0`);
  console.log(`      --port, -p <port>`);
  console.log(`        Specify the port to listen.`);
  console.log(`        Default: 13808`);
  console.log(`  host [options]`);
  console.log(`    Start the host proxy server, where the real traffic outlets.`);
}

// src/utils/options.ts
var map = /* @__PURE__ */ new Map();
var args = [];
var command;
function parse(str) {
  command = str[0];
  str.slice(1).forEach((s) => {
    let [name, value] = s.split("=").map((x) => x.trim());
    while (name.startsWith("-")) {
      name = name.slice(1);
    }
    if (!name)
      return;
    map.set(name, value);
    args.push([name, value]);
  });
}
function getArgs() {
  return Array.from(args);
}
function getCommand() {
  return command;
}

// src/index.ts
async function main() {
  parse(process.argv.slice(2));
  const cmd = getCommand();
  if (!cmd) {
    printUsage();
  }
  switch (cmd) {
    case "list":
      listSerialPorts().then((list) => {
        console.log(`Available serial ports:`);
        list.forEach((p, i) => {
          console.log(`[${i + 1}]  ${p.path}`);
          console.log(`      Manu.:${p.manufacturer} Vend.:${p.vendorId} Prod.:${p.productId}`);
          console.log("");
        });
      }).catch((err) => console.error(err));
      break;
    case "proxy":
      break;
    case "host":
      break;
    case "test":
      await test(getArgs());
      break;
    default:
      printUsage();
  }
}
main();
